(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('rxjs-debug', ['exports', 'rxjs', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['rxjs-debug'] = {}, global.rxjs, global.rxjs.operators));
}(this, (function (exports, rxjs, operators) { 'use strict';

    /*
    MIT License

    Copyright (c) 2020 Ankit Singh <dabalyan@hotmail.com>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

    This license applies to the complete mono-repo, unless specified otherwise.
    */

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var _a;
    var NUM = 5;
    var OF$ = rxjs.of(1);
    var MAPPER = function () { return OF$; };
    var NOOP = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
    var OPERATORS_BY_CATEGORY = {
        conditional: ['defaultIfEmpty', 'every', 'find', 'findIndex', 'isEmpty', 'throwIfEmpty'],
        errorHandling: ['catchError', 'retry', 'retryWhen', 'onErrorResumeNext'],
        filter: [
            'take',
            'takeLast',
            'takeUntil',
            'takeWhile',
            'audit',
            'debounce',
            'debounceTime',
            'distinct',
            'distinctUntilChanged',
            'elementAt',
            'filter',
            'first',
            'ignoreElements',
            'last',
            'sample',
            'sampleTime',
            'single',
            'skip',
            'skipLast',
            'skipUntil',
            'skipWhile',
            'throttle',
            'throttleTime',
        ],
        join: ['combineAll', 'startWith', 'exhaust', 'withLatestFrom', 'endWith'],
        joinCreation: ['combineLatest', 'concat', 'merge', 'partition', 'race', 'zip', 'zipAll'],
        mathAndAggregate: ['count', 'reduce'],
        multicast: [
            'share',
            'multicast',
            'shareReplay',
            'publishBehavior',
            'publishLast',
            'publishReplay',
        ],
        transformation: [
            'map',
            'mapTo',
            'buffer',
            'bufferCount',
            'bufferTime',
            'bufferToggle',
            'bufferWhen',
            'switchMap',
            'exhaustMap',
            'pairwise',
            'pluck',
            'scan',
            'expand',
            'groupBy',
            'mergeMap',
            'mergeScan',
            'windowCount',
            'windowTime',
            'windowToggle',
            'windowWhen',
        ],
        utility: [
            'delay',
            'delayWhen',
            'finalize',
            'dematerialize',
            'materialize',
            'tap',
            'observeOn',
            'refCount',
            'toArray',
            'repeat',
            'repeatWhen',
            'sequenceEqual',
            'subscribeOn',
            'timeInterval',
            'timeoutWith',
        ],
    };
    var COLOR_GENERATORS_BY_CATEGORY = {
        conditional: function (a) { return "rgba(200,200,200," + (a || 1) + ")"; },
        errorHandling: function (a) { return "rgba(255,0,120," + (a || 1) + ")"; },
        filter: function (a) { return "rgba(255,255,0," + (a || 1) + ")"; },
        join: function (a) { return "rgba(0,125,255," + (a || 1) + ")"; },
        joinCreation: function (a) { return "rgba(255,100,0," + (a || 1) + ")"; },
        mathAndAggregate: function (a) { return "rgba(200,200,200," + (a || 1) + ")"; },
        multicast: function (a) { return "rgba(0,255,217," + (a || 1) + ")"; },
        transformation: function (a) { return "rgba(17,255,0," + (a || 1) + ")"; },
        utility: function (a) { return "rgba(245,0,255," + (a || 1) + ")"; },
    };
    var OPERATORS_BY_RETURNED_FN_BODY = (_a = {},
        _a[String(operators.audit(MAPPER))] = 'audit',
        // [String(auditTime(NUM))]: 'auditTime', // audit
        _a[String(operators.buffer(OF$))] = 'buffer',
        _a[String(operators.bufferCount(NUM))] = 'bufferCount',
        _a[String(operators.bufferTime(NUM))] = 'bufferTime',
        _a[String(operators.bufferToggle(OF$, MAPPER))] = 'bufferToggle',
        _a[String(operators.bufferWhen(MAPPER))] = 'bufferWhen',
        _a[String(operators.catchError(MAPPER))] = 'catchError',
        _a[String(operators.combineAll())] = 'combineAll',
        _a[String(operators.combineLatest([OF$]))] = 'combineLatest',
        _a[String(operators.concat())] = 'concat',
        // [String(concatAll())]: 'concatAll', // mergeMap
        // [String(concatMap(MAPPER))]: 'concatMap', // mergeMap
        // [String(concatMapTo(MAPPER))]: 'concatMapTo', // mergeMap
        _a[String(operators.count())] = 'count',
        _a[String(operators.debounce(MAPPER))] = 'debounce',
        _a[String(operators.debounceTime(NUM))] = 'debounceTime',
        _a[String(operators.defaultIfEmpty())] = 'defaultIfEmpty',
        _a[String(operators.delay(NUM))] = 'delay',
        _a[String(operators.delayWhen(MAPPER))] = 'delayWhen',
        _a[String(operators.dematerialize())] = 'dematerialize',
        _a[String(operators.distinct())] = 'distinct',
        _a[String(operators.distinctUntilChanged())] = 'distinctUntilChanged',
        // [String(distinctUntilKeyChanged<[]>(NUM))]: 'distinctUntilKeyChanged', // distinctUntilChanged
        _a[String(operators.elementAt(NUM))] = 'elementAt',
        _a[String(operators.endWith())] = 'endWith',
        _a[String(operators.every(NOOP))] = 'every',
        _a[String(operators.exhaust())] = 'exhaust',
        _a[String(operators.exhaustMap(MAPPER))] = 'exhaustMap',
        _a[String(operators.expand(MAPPER))] = 'expand',
        _a[String(operators.filter(NOOP))] = 'filter',
        _a[String(operators.finalize(MAPPER))] = 'finalize',
        _a[String(operators.find(NOOP))] = 'find',
        _a[String(operators.findIndex(NOOP))] = 'findIndex',
        _a[String(operators.first())] = 'first',
        _a[String(operators.groupBy(MAPPER))] = 'groupBy',
        _a[String(operators.ignoreElements())] = 'ignoreElements',
        _a[String(operators.isEmpty())] = 'isEmpty',
        _a[String(operators.last())] = 'last',
        _a[String(operators.map(MAPPER))] = 'map',
        _a[String(operators.mapTo(MAPPER))] = 'mapTo',
        _a[String(operators.materialize())] = 'materialize',
        // [String(max())]: 'max', // reduce
        _a[String(operators.merge())] = 'merge',
        // [String(mergeAll())]: 'mergeAll', // mergeMap
        _a[String(operators.mergeMap(MAPPER))] = 'mergeMap',
        // [String(flatMap(MAPPER))]: 'flatMap', // mergeMap
        // [String(mergeMapTo(MAPPER))]: 'mergeMapTo', // mergeMap
        _a[String(operators.mergeScan(MAPPER, NUM))] = 'mergeScan',
        // [String(min())]: 'min', // reduce
        _a[String(operators.multicast(new rxjs.Subject()))] = 'multicast',
        _a[String(operators.observeOn(rxjs.asapScheduler))] = 'observeOn',
        _a[String(operators.onErrorResumeNext())] = 'onErrorResumeNext',
        _a[String(operators.pairwise())] = 'pairwise',
        _a[String(operators.partition(NOOP))] = 'partition',
        _a[String(operators.pluck(''))] = 'pluck',
        // [String(publish())]: 'publish', // multicast
        _a[String(operators.publishBehavior(MAPPER))] = 'publishBehavior',
        _a[String(operators.publishLast())] = 'publishLast',
        _a[String(operators.publishReplay())] = 'publishReplay',
        _a[String(operators.race())] = 'race',
        _a[String(operators.reduce(MAPPER))] = 'reduce',
        _a[String(operators.repeat())] = 'repeat',
        _a[String(operators.repeatWhen(MAPPER))] = 'repeatWhen',
        _a[String(operators.retry())] = 'retry',
        _a[String(operators.retryWhen(MAPPER))] = 'retryWhen',
        _a[String(operators.refCount())] = 'refCount',
        _a[String(operators.sample(OF$))] = 'sample',
        _a[String(operators.sampleTime(NUM))] = 'sampleTime',
        _a[String(operators.scan(MAPPER))] = 'scan',
        _a[String(operators.sequenceEqual(OF$))] = 'sequenceEqual',
        _a[String(operators.share())] = 'share',
        _a[String(operators.shareReplay())] = 'shareReplay',
        _a[String(operators.single())] = 'single',
        _a[String(operators.skip(NUM))] = 'skip',
        _a[String(operators.skipLast(NUM))] = 'skipLast',
        _a[String(operators.skipUntil(OF$))] = 'skipUntil',
        _a[String(operators.skipWhile(NOOP))] = 'skipWhile',
        _a[String(operators.startWith(MAPPER))] = 'startWith',
        _a[String(operators.subscribeOn(rxjs.asapScheduler))] = 'subscribeOn',
        // [String(switchAll())]: 'switchAll', // switchMap
        _a[String(operators.switchMap(MAPPER))] = 'switchMap',
        // [String(switchMapTo(OF$))]: 'switchMapTo', // switchMap
        _a[String(operators.take(NUM))] = 'take',
        _a[String(operators.takeLast(NUM))] = 'takeLast',
        _a[String(operators.takeUntil(OF$))] = 'takeUntil',
        _a[String(operators.takeWhile(NOOP))] = 'takeWhile',
        _a[String(operators.tap(MAPPER))] = 'tap',
        _a[String(operators.throttle(MAPPER))] = 'throttle',
        _a[String(operators.throttleTime(NUM))] = 'throttleTime',
        _a[String(operators.throwIfEmpty(MAPPER))] = 'throwIfEmpty',
        _a[String(operators.timeInterval(rxjs.asapScheduler))] = 'timeInterval',
        // [String(timeout(NUM))]: 'timeout', // timeoutWith
        _a[String(operators.timeoutWith(NUM, OF$))] = 'timeoutWith',
        // [String(timestamp(asapScheduler))]: 'timestamp', // map
        _a[String(operators.toArray())] = 'toArray',
        _a[String(operators.windowCount(NUM))] = 'windowCount',
        _a[String(operators.windowTime(NUM))] = 'windowTime',
        _a[String(operators.windowToggle(OF$, MAPPER))] = 'windowToggle',
        _a[String(operators.windowWhen(MAPPER))] = 'windowWhen',
        _a[String(operators.withLatestFrom())] = 'withLatestFrom',
        _a[String(operators.zip())] = 'zip',
        _a[String(operators.zipAll())] = 'zipAll',
        _a);
    var COLORS_BY_OPERATOR = {
        source: 'rgb(240,240,240)',
    };
    Object.entries(OPERATORS_BY_CATEGORY).forEach(function (_a) {
        var _b = __read(_a, 2), cat = _b[0], ops = _b[1];
        var span = 0.3 / ops.length;
        ops.forEach(function (op, i) {
            COLORS_BY_OPERATOR[op] = COLOR_GENERATORS_BY_CATEGORY[cat]((1 - span * i).toFixed(2));
            /*console.log(
              `%c ${op} `,
              `background-color: #000; padding: 3px; border-radius: 6px;color: ${colorGenByCat[cat](
                1 - span * i
              )}`
            );*/
        });
    });

    var lastLogDebuggerId;
    var lastLogOperatorExecCountMsg;
    var PREFIX = '➰ ';
    var Logger = /** @class */ (function () {
        function Logger(debuggerId, operators, hideOutputs, noStyling) {
            this.debuggerId = debuggerId;
            this.hideOutputs = hideOutputs;
            this.noStyling = noStyling;
            this.operatorsExecCountMap = {};
            this.longestOperatorExecCountMsgLen = 0;
            this.subCount = 0;
            this.startMsg = debuggerId + ' >> START';
            this.endMsg = debuggerId + ' >> END';
            this.subscriptionMsg = debuggerId + ' >> SUBSCRIBED';
            this.erroredMsg = debuggerId + ' >> ERRORED';
            this.completedMsg = debuggerId + ' >> COMPLETED';
            this.basePad = 7;
            this.pad =
                this.basePad +
                    Math.max(this.startMsg.length, this.endMsg.length, this.subscriptionMsg.length, this.completedMsg.length);
            this.operatorNames = ['source'].concat(operators.map(function (op) { return OPERATORS_BY_RETURNED_FN_BODY[String(op)] || ''; }));
            this.longestNameLen = this.operatorNames.reduce(function (a, b) { return (a.length > b.length ? a : b); }).length;
        }
        Logger.prototype.logStart = function () {
            var msg = this.startMsg.padEnd(this.basePad + this.pad, '_');
            console.log(this.newLines(2) + PREFIX + msg + this.subCountMsg.padStart(4, '_') + '__▽');
        };
        Logger.prototype.logResume = function () {
            if ((lastLogDebuggerId && lastLogDebuggerId !== this.debuggerId) ||
                (lastLogOperatorExecCountMsg &&
                    lastLogOperatorExecCountMsg !== this.currentOperatorExecCountMsg)) {
                var msg = this.debuggerId.padEnd(this.basePad + this.pad, '_');
                console.log(this.newLines(2) + PREFIX + msg + this.subCountMsg.padStart(4, '_') + '___');
            }
        };
        Logger.prototype.logEnd = function () {
            var msg = this.endMsg.padEnd(this.basePad + this.pad, '‾');
            console.log(PREFIX + msg + this.subCountMsg.padStart(4, '‾') + '‾‾△' + this.newLines(3));
        };
        Logger.prototype.logOperator = function (opIndex, value) {
            var opName = this.operatorNames[opIndex];
            var opIndexStr = String(opIndex).padStart(2, ' ');
            var paddedIndexAndName = (opIndexStr + ' ' + opName).padEnd(this.longestNameLen + 4, ' ');
            var paddedExecCountMsg = ("" + this.currentOperatorExecCountMsg)
                .padStart(this.longestOperatorExecCountMsgLen, ' ')
                .padEnd(this.longestOperatorExecCountMsgLen + 1, ' ');
            console.log(PREFIX + (this.noStyling ? '' : '%c') + paddedIndexAndName + paddedExecCountMsg, this.noStyling
                ? ''
                : "color: " + COLORS_BY_OPERATOR[opName] + "; background-color: #000; padding: 3px; border-radius: 6px;", this.hideOutputs === true ? '' : value);
            lastLogDebuggerId = this.debuggerId;
            lastLogOperatorExecCountMsg = this.currentOperatorExecCountMsg;
        };
        Logger.prototype.prepare = function (opIndex) {
            var _a;
            var opName = this.operatorNames[opIndex];
            this.operatorsExecCountMap[opIndex + opName] =
                ((_a = this.operatorsExecCountMap[opIndex + opName]) !== null && _a !== void 0 ? _a : 0) + 1;
            this.currentOperatorExecCountMsg =
                this.operatorsExecCountMap[opIndex + opName] > 1
                    ? " (" + this.operatorsExecCountMap[opIndex + opName] + ")"
                    : '';
            this.longestOperatorExecCountMsgLen = Math.max(this.longestOperatorExecCountMsgLen, this.currentOperatorExecCountMsg.length);
        };
        Logger.prototype.addSubscription = function () {
            this.subCount++;
            this.subCountMsg = this.subCount > 1 ? "S:" + this.subCount : '';
            var msg = this.subscriptionMsg.padEnd(this.basePad + this.pad, '-');
            console.log(this.newLines(1) + PREFIX + msg + this.subCountMsg.padStart(4, '-') + '--▼' + this.newLines(2));
        };
        Logger.prototype.logErrored = function () {
            var msg = this.erroredMsg.padEnd(this.basePad + this.pad, '-');
            console.log(this.newLines(1) + PREFIX + msg + this.subCountMsg.padStart(4, '-') + '--▲' + this.newLines(2));
        };
        Logger.prototype.logCompleted = function () {
            var msg = this.completedMsg.padEnd(this.basePad + this.pad, '-');
            console.log(this.newLines(1) + PREFIX + msg + this.subCountMsg.padStart(4, '-') + '--▲' + this.newLines(2));
        };
        Logger.prototype.newLines = function (n) {
            return this.noStyling ? '' : Array(n).fill('\n').join('');
        };
        return Logger;
    }());

    var debuggersCount = 0;
    /**
     * RxJS-Debug wrapper function, to enable automated logging for Observables and Streams.
     *
     * When an Observable is wrapped with this function,
     * it returns the same Observable after injecting the logging hooks into it.
     *
     * It overrides the `subscribe` and `pipe` methods and
     * replaces them with the custom trapped versions to achieve the expected monitoring and logging behavior.
     *
     * @example
     * ```ts
     * // raw Observable
     * const source$ = of(1, 2, 3)
     *
     * // wrapped Observable with automatic logging enabled
     * const sourceWithAutomaticLogging$ = $D(source$)
     *
     * // subscribe to start the logging
     * sourceWithAutomaticLogging$.subscribe()
     *
     * // you'll see the logging in the console
     *
     * // the target use-case would be when there are multiple operators applied
     * $D(source$).pipe(
     *   map(x => x + 5),
     *   switchMap(x => of(x * 2)),
     * )
     *
     * // you'll see even more detailed and useful logging in the console
     * ```
     *
     * @param $ The Observable that needs to be debugged.
     * @param options Configuration options for RxJS-Debug instance.
     * @returns A copy of the passed Observable, with logging enabled.
     */
    function $D($, options) {
        var _a;
        var d$ = new rxjs.Observable();
        d$.source = $;
        $ = d$;
        options = options || {};
        var debuggerId = String((_a = options.id) !== null && _a !== void 0 ? _a : ++debuggersCount);
        var ogSubscribe = $.subscribe;
        var ogPipe = $.pipe;
        var logger;
        $.pipe = function () {
            var operators$1 = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                operators$1[_i] = arguments[_i];
            }
            logger = new Logger(debuggerId, operators$1, options.hideOutputs, options.noStyling);
            var injections = logger.operatorNames.length;
            var _loop_1 = function (i) {
                var tapper = operators.tap(function (value) {
                    logger.prepare(i);
                    if (i === 0) {
                        logger.logStart();
                    }
                    else {
                        logger.logResume();
                    }
                    logger.logOperator(i, value);
                    if (i === injections - 1) {
                        logger.logEnd();
                    }
                });
                operators$1.splice(i + i, 0, tapper);
            };
            for (var i = 0; i < injections; i++) {
                _loop_1(i);
            }
            if (typeof options.addDelay === 'number') {
                var delayer = operators.delay(options.addDelay);
                var totalInjections = operators$1.length;
                for (var i = 0; i < totalInjections; i++) {
                    operators$1.splice(i + i, 0, delayer);
                }
            }
            operators$1.push(operators.catchError(function (err) {
                logger.logErrored();
                return rxjs.throwError(err);
            }));
            operators$1.push(operators.tap({ complete: function () { return logger.logCompleted(); } }));
            return ogPipe.apply(this, operators$1);
        };
        $.subscribe = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!logger) {
                var tappedObservable = $.pipe();
                return tappedObservable.subscribe.apply(tappedObservable, __spread(args));
            }
            logger.addSubscription();
            return ogSubscribe.apply(this, args);
        };
        return $;
    }

    /*
     * Public API Surface of rxjs-debug
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.$D = $D;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=rxjs-debug.umd.js.map
